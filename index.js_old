var Q = require('q-plus');
var _ = require('lodash');
var domain = require('domain');
var logger = require('./utils/logger')('jobs');
var disque = require('thunk-disque');

// Polling delay in secs when no workers are available
var POLL_DELAY = 15;

// Timeout in ms before a job is considered as failed
var TIMEOUT_JOB = 60*60*1000;
// Timeout in ms to wait for a job
var TIMEOUT_DEQUEUE = 15*1000;

var DEFAULT = '_queue';
var FAILED = '_failed';
var FAILED_TTL = 3*24*60*60;
var COMPLETED = '_completed';
var COMPLETED_TTL = 3*24*60*60;

logger.log('Initialize job queue with disque');

function Jobber() {
    this.client = disque.createClient(7711, { usePromise: true });
    this.pollTimeout = null;
    this.workers = {};
    this.processing = {};
    this.running = true;
    this.poll();
}

// Push a new job in the queue
Jobber.prototype.pushJob = function(type, payload) {
    logger.log('push job', type);
    return this.client.addjob(type, JSON.stringify(payload), 0);
};

// Register a new job handler
Jobber.prototype.registerHandler = function(handler) {
    this.workers[handler.type] = {
        type: handler.type || DEFAULT,
        current: 0,
        concurrency: handler.concurrency || 1,
        maxAttemps: handler.maxAttemps || 1,
        exec: function(job) {
            var d = Q.defer();
            var dmn = domain.create();

            var cleanup = function() {
                // Cleanup domain
                dmn.removeAllListeners();
            };

            var next = function(err) {
                cleanup();

                if (err) d.reject(err);
                else d.resolve();
            };

            dmn.once('error', function(err) {
                logger.critical('Domain exception occured!');
                cleanup();
                next(err);
            });
            dmn.run(function() {
                Q()
                .then(function() {
                    return handler.exec(job.payload, job);
                })
                .nodeify(next);
            });

            return d.promise;
        }
    };
};

// Return a count of available workers
Jobber.prototype.countAvailableWorkers = function() {
    var that = this;
    return _.reduce(that.workers, function(count, worker) {
        return count + (worker.concurrency - worker.current);
    }, 0);
};

// Get a list of handled types
Jobber.prototype.listTypes = function() {
    return _.chain(this.workers)
    .map('type')
    .value();
};

// Delay polling
Jobber.prototype.delayPoll = function() {
    var that = this;

    if (that.pollTimeout) {
        clearTimeout(that.pollTimeout);
        that.pollTimeout = null;
    }

    logger.log('delay polling by '+POLL_DELAY+' seconds');
    that.pollTimeout = setTimeout(function() {
        that.pollTimeout = null;
        that.poll();
    }, POLL_DELAY*1000);
};

// Poll a job and execute it
Jobber.prototype.poll = function() {
    var that = this;
    if (!that.running) return;

    var nWorkers = 0;
    var availableWorkers = that.countAvailableWorkers();

    if (availableWorkers == 0) {
        logger.warn('no workers available');
        return that.delayPoll();
    }

    // List jobs that have available workers
    var types = _.chain(that.workers)
        .filter(function(worker) {
            nWorkers = nWorkers + worker.concurrency;
            return (worker.current < worker.concurrency);
        })
        .map('type')
        .value();


    logger.log('poll job with', types.length, 'types; worker availables: ', availableWorkers+'/'+nWorkers);
    that.client.getjob(['TIMEOUT', TIMEOUT_DEQUEUE, 'WITHCOUNTERS', 'FROM'].concat(types))
    .then(function(res) {
        logger.log('job is available:', !!res);

        // No job available, reset TIMEOUT
        if (!res) return that.poll();

        // Convert returned array to an element
        res = res.length > 0? res[0] : null;
        // Reformat job info
        var job = {
            type: res[0],
            id: res[1],
            payload: JSON.parse(res[2]),
            nacks: res[4],
            additionalDeliveries: res[6]
        };

        // Mark worker as taken and process
        availableWorkers -= 1;
        that.processJob(job)
        .fin(function() {
            return that.poll();
        });

        // There are maybe other jobs pending,
        // and we still have concurrent workers available
        if (availableWorkers > 0) {
            return that.poll();
        }
    })
    .catch(function(err) {
        logger.critical('error polling:');
        logger.exception(err);
        return that.delayPoll();
    });
};

// Process a job
Jobber.prototype.processJob = function(job) {
    var that = this;

    return Q()
    .then(function() {
        logger.log('start job', job.id, 'of type', job.type);

        // No registered handler for this type
        if (!that.workers[job.type]) throw new Error('No handler for this job');

        // Increase count of processing
        that.workers[job.type].current += 1;

        that.processing[job.id] = that.wrapJobprocess(job, that.workers[job.type].exec(job));
        return that.processing[job.id];
    })
    .fail(function(err) {
        logger.critical('errroor !!');
        logger.exception(err);
    })
    .fin(function() {
        delete that.processing[job.id];

        // Decrease count of processing
        if (that.workers[job.type]) {
            that.workers[job.type].current -= 1;
        }
    });
};

// Wrap job processing with exec function
Jobber.prototype.wrapJobprocess = function(job, exec) {
    var that = this;

    return Q(exec)
    .timeout(TIMEOUT_JOB, 'took longer than '+Math.ceil(TIMEOUT_JOB/1000)+' seconds to process')
    .then(function(result) {
        // Acknowledge job to disque
        return that.acknowledgeJob(job);
    }, function(err) {
        return that.handleFailedJob(job, err);
    });
};

// Acknowledge job to disque then push to completed queue
Jobber.prototype.acknowledgeJob = function(job) {
    var that = this;

    return that.client.ackjob(job.id)
    .then(function() {
        logger.log('job', job.id, 'is done');
        return that.client.addjob(COMPLETED, JSON.stringify(job.payload), 0, 'TTL', COMPLETED_TTL);
    });
};

// Handle failed job: nack and requeue or push to failed
Jobber.prototype.handleFailedJob = function(job, err) {
    // Get maxAttempts for this type of job
    var maxAttemps = that.workers[job.type].maxAttemps;

    logger.error('error with job ', job.id, ':');
    logger.exception(err);

    // Too many nacks, push to failed queue
    if (job.nacks >= maxAttemps) {
        // Add error info to job
        logger.log('job has been marked as failed');
        job.payload.error.message = err.message;
        job.payload.error.stack = err.stack;
        return that.client.addjob(FAILED, JSON.stringify(job.payload), 0, 'TTL', FAILED_TTL);
    }
    // Requeue job
    else {
        logger.log('requeuing job for the '+smartCount(job.nacks+1)+' time');
        return that.client.nack(job.id);
    }
};

// Shutdown the client
Jobber.prototype.shutdown = function(n, cb) {
    var that = this;
    that.running = false;

    if (_.size(that.processing) == 0) {
        that.client.clientEnd();
        return cb();
    }

    // Maximum wait
    var timeout = setTimeout(cb, n);

    return Q.all(_.values(that.processing))
    .fin(function() {
        clearTimeout(timeout);
        that.client.clientEnd();
        cb();
    });
};

// Return a job's details
Jobber.prototype.details = function(jobId) {
    var job = that.client.show(jobId);
    job.payload = JSON.parse(job.payload);
    return job;
};

// Count completed jobs
Jobber.prototype.countCompleted = function() {
    return this.client.qlen(COMPLETED);
};

// List of completed jobs
Jobber.prototype.listCompleted = function(opts) {
    var that = this;

    opts = _.defaults(opts || {}, {
        start: 0,
        limit: 100
    });

    return that.client.jscan(opts.start, 'COUNT', opts.limit, 'QUEUE', COMPLETED, 'REPLY', 'all')
    .then(function(res) {
        return res[1].map(mapScan);
    });
};

// Count failed jobs
Jobber.prototype.countFailed = function() {
    return this.client.qlen(FAILED);
};

// List of failed jobs
Jobber.prototype.listFailed = function(opts) {
    var that = this;

    opts = _.defaults(opts || {}, {
        start: 0,
        limit: 100
    });

    return that.client.jscan(opts.start, 'COUNT', opts.limit, 'QUEUE', FAILED, 'REPLY', 'all')
    .then(function(res) {
        return res[1].map(mapScan);
    });
};

// Count jobs for a type and a state
Jobber.prototype.countType = function(type, state) {
    if (!status) return this.client.qlen(type);
    return this.client.jscan('QUEUE', type, 'STATE', state)
    .then(function(res) {
        return res[1].length;
    });
};

// List of pending jobs
Jobber.prototype.listPending = function(opts, type) {
    var that = this;

    opts = _.defaults(opts || {}, {
        start: 0,
        limit: 100
    });

    if (!!type) {
        return that.client.jscan(opts.start, 'COUNT', opts.limit, 'QUEUE', type, 'STATE', 'queued', 'REPLY', 'all')
        .then(function(res) {
            return res[1].map(mapScan);
        });
    }

    // Get concerned queues based on opts.start and opts.limit
    var count = 0;
    var current;

    Q(that.listTypes()).eachSeries(function(type, i) {
        if (count > opts.start) return Q();
        return that.countType(type, 'queued')
        .then(function(length) {

        });
    });
    while (count < opts.start) {
        that.listTypes
    }
};

// List of active jobs
Jobber.prototype.listActive = function(opts) {
    // body...
};

// Get count of query
function queryCountJobs(status) {
    return Job.getByStatus(status).countQ();
}

// Remove a job
Jobber.prototype.removeJob = function(id) {
    var that = this;
    if (_.isArray(id)) return Q.all(_.map(id, that.removeJob));

    return that.client.deljob(id);
}

// Cancel a job
function cancelJob(id) {
    if (_.isArray(id)) return Q.all(_.map(id, cancelJob));

    return getJob(id)
    .then(function(job) {
        return job.cancel();
    });
}

// Clean completed jobs
function cleanCompleted(after) {
    return Job.removeQ({
        status: {
            '$in': [ Job.STATUS.COMPLETE, Job.STATUS.FAILED ]
        },
        ended: {
            '$lt': after
        }
    });
}

// Restart jobs that are stuck as active
// types should be a list: { id: "", restart: 0 }
function watchStuckActive(types, limitShutdown) {
    var startTime = Date.now();
    limitShutdown = new Date(limitShutdown || (startTime - TIMEOUT_JOB));

    function update(types, query, update) {
        if (!types || types.length == 0) return Q();

        query = _.extend(query, {
            type: {
                '$in': types
            },
            status: Job.STATUS.DEQUEUED
        });
        return Job.updateQ(query, update, {
            upsert: false,
            multi: true
        });
    }

    // Group by delay
    var groups = _.chain(types)
        .groupBy(function(type) {
            return type.restart || 0;
        })
        .mapValues(function(values) {
            return _.pluck(values, 'id');
        })
        .value();

    return _.reduce(groups, function(prev, typeIds, restart) {
        restart = Number(restart);
        var limitRestartDate = new Date(limitShutdown - restart);

        return prev.then(function() {
            if (restart === 0) return;

            logger.log('restarting stuck jobs between', limitRestartDate, '-', limitShutdown);
            return update(typeIds, {
                updated: {
                    '$gt': limitRestartDate,
                    '$lt': limitShutdown
                }
            }, {
                status: Job.STATUS.PENDING,
                created: startTime,
                updated: startTime,
                ended: null
            });
        })
        .then(function(result) {
            if (result) logger.log(result.n+' jobs restarted');

            logger.log('stopping stuck jobs between since', limitShutdown);
            return update(typeIds, {
                updated: {
                    '$lt': limitShutdown
                }
            }, {
                status: Job.STATUS.FAILED,
                updated: startTime,
                ended: startTime,
                error: {
                    message: 'Shutdown'
                }
            });
        })
        .then(function(result) {
            logger.log(result.n+' jobs cancelled');
        });
    }, Q());
}

// Map results of a disque JSCAN to its SHOW equivalent
function mapScan(res) {
    var job = {};
    for (var i = 0; i < res.length; i+=2) {
        job[res[i]] = res[i+1];
    }

    job.body = JSON.parse(job.body);
    return job;
}

function smartCount(n) {
    return n+(n > 3? 'th': (n === 3)? 'rd': (n === 2)? 'nd' : 'st');
}

module.exports = Jobber;
